using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using WateryTart.MusicAssistant.Generators;

namespace WateryTart.Service.MassClient.Generators;

[Generator]
public class JsonContextSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classSyntax = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => node is ClassDeclarationSyntax,
                transform: (ctx, _) => ctx.Node)
            .Where(n => n is not null)
            .Collect();

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(classSyntax),
            (ctx, pair) =>
            {
                var (compilation, _) = pair;
                GenerateJsonSerializableAttributes(ctx, compilation);
            });
    }

    private static void GenerateJsonSerializableAttributes(SourceProductionContext context, Compilation compilation)
    {
        try
        {
            var allTypes = compilation.GlobalNamespace.GetAllTypes().ToList();

            var matchingTypes = allTypes
                .Where(t => IsMatchingType(t))
                .OrderBy(t => t.ContainingNamespace.ToDisplayString())
                .ThenBy(t => t.Name)
                .ToList();

            // Find the MassClientJsonContext class and extract JsonContextInclude attributes
            var contextClass = allTypes.FirstOrDefault(t => t.Name == "MediaAssistantJsonContext" && 
                t.ContainingNamespace.ToDisplayString().Contains("Messages"));

            var includedTypes = new List<string>();
            if (contextClass?.DeclaringSyntaxReferences.Length > 0)
            {
                var syntax = contextClass.DeclaringSyntaxReferences[0].GetSyntax() as ClassDeclarationSyntax;
                if (syntax != null)
                {
                    var includeAttrs = syntax.AttributeLists
                        .SelectMany(al => al.Attributes)
                        .Where(a => a.Name.ToString().EndsWith("JsonContextInclude"))
                        .ToList();

                    foreach (var attr in includeAttrs)
                    {
                        if (attr.ArgumentList?.Arguments.FirstOrDefault()?.Expression is TypeOfExpressionSyntax typeOf)
                        {
                            includedTypes.Add(typeOf.Type.ToString());
                        }
                    }
                }
            }

            if (!matchingTypes.Any() && !includedTypes.Any())
                return;

            var source = GenerateAttributeSource(matchingTypes, includedTypes);
            context.AddSource("MediaAssistantJsonContext.g.cs", SourceText.From(source, Encoding.UTF8));
        }
        catch (Exception ex)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    "JCSG001",
                    "Source Generator Error",
                    $"Failed: {ex.Message}",
                    "SourceGenerator",
                    DiagnosticSeverity.Error,
                    true),
                Location.None));
        }
    }

    private static bool IsMatchingType(INamedTypeSymbol symbol)
    {
        // Must be Class or Enum, AND not abstract
        if ((symbol.TypeKind == TypeKind.Class || symbol.TypeKind == TypeKind.Enum) &&
            !symbol.IsAbstract)
        {
            var fullNamespace = symbol.ContainingNamespace.ToDisplayString();
            var qualifiedName = symbol.ToDisplayString();

            // Exclude open generic type definitions (e.g., ResponseBase<T>)
            // But include concrete types even if they inherit from generics (e.g., TempResponse : ResponseBase<object>)
            if (symbol.IsGenericType && symbol.TypeParameters.Any())
                return false;

            return fullNamespace.Contains(".Models") ||
                   fullNamespace.Contains(".Responses") ||
                   fullNamespace.Contains(".Events") ||
                   fullNamespace.Contains(".Messages");
        }

        return false;
    }

    private static string GenerateAttributeSource(List<INamedTypeSymbol> types, List<string> includedTypes, string targetNamespace = "WateryTart.MusicAssistant")
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine("using WateryTart.MusicAssistant.Responses;");
        sb.AppendLine();
        sb.AppendLine($"namespace {targetNamespace};");
        sb.AppendLine();
        
        //// Add JsonSourceGenerationOptions
        //sb.AppendLine("[JsonSourceGenerationOptions(");
        //sb.AppendLine("    PropertyNamingPolicy = JsonKnownNamingPolicy.SnakeCaseLower,");
        //sb.AppendLine("    PropertyNameCaseInsensitive = true,");
        //sb.AppendLine("    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,");
        //sb.AppendLine("    WriteIndented = false)]");
        //sb.AppendLine();

        // Add all regular types
        foreach (var type in types)
        {
            sb.AppendLine($"[JsonSerializable(typeof({type.ToDisplayString()}))]");
        }

        // Add user-included types from attributes
        foreach (var includedType in includedTypes.Distinct().OrderBy(x => x))
        {
            sb.AppendLine($"[JsonSerializable(typeof({includedType}))]");
        }

        // Collect all ResponseBase<T> type arguments from concrete response types
        var responseBaseTypes = new HashSet<string>();
        foreach (var type in types)
        {
            var baseType = type.BaseType;
            while (baseType != null)
            {
                if (baseType.Name == "ResponseBase" && baseType.IsGenericType)
                {
                    var typeArg = baseType.TypeArguments.FirstOrDefault();
                    if (typeArg != null)
                    {
                        responseBaseTypes.Add($"ResponseBase<{typeArg.ToDisplayString()}>");
                    }
                }
                baseType = baseType.BaseType;
            }
        }

        foreach (var responseType in responseBaseTypes.OrderBy(x => x))
        {
            sb.AppendLine($"[JsonSerializable(typeof({responseType}))]");
        }

        sb.AppendLine("public partial class MediaAssistantJsonContext : JsonSerializerContext { }");

        return sb.ToString();
    }
}